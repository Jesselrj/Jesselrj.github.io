{"posts":[{"title":"各种积分","text":"$Guass$积分$$\\int_{0}^{+\\infty}e^{-x^{2}}dx$$ 设$I(t)={(\\int_{0}^{t} e^{-x^{2}}dx)}^2$, 则求 $$\\sqrt{\\lim\\limits_{t \\to +\\infty}I(t)}$$ $$I^{‘}(t) = 2(\\int_{0}^{t}e^{-x^{2}}dx)e^{-t^2} = 2\\int_{0}^{t}e^{-x^2-t^2}dx = 2\\int_{0}^{1}2te^{(y^2+1)t^2}dy$$ $$\\frac{dI(t)}{dt} = \\frac{\\int_0^1\\frac{e^{-(y^2+1)t^2}}{-(y^2+1)}dy}{dt}$$ $$I(t) = \\int_0^1\\frac{e^{-(y^2+1)t^2}}{-(y^2+1)}+C$$ $$I(0)=\\int_0^1\\frac{-1}{y^2+1}dy+C = -\\frac{\\pi}{4} + C=0,C=\\frac{\\pi}{4}$$ $$I(t) = \\int_0^1\\frac{e^{-(y^2+1)t^2}}{-(y^2+1)}+\\frac{\\pi}{4}$$ $$\\lim\\limits_{t \\to +\\infty}I(t)=0+\\frac{\\pi}{4} = \\frac{\\pi}{4}$$ $$\\therefore\\int_{0}^{+\\infty}e^{-x^{2}}dx=\\frac{\\sqrt{\\pi}}{2}$$ $Euler$积分$Beta$函数$$B(p,q)=\\int_0^1x^{p-1}(1-x)^{q-1}dx\\ (p &gt; 0, q &gt; 0)$$ $$let\\ x = \\sin^2\\theta,B(p,q)=\\int_0^{\\frac{\\pi}{2}}{(\\sin\\theta)^{2p-2} (\\cos\\theta)^{2q-2} d(\\sin^2\\theta)} = \\int_0^{\\frac{\\pi}{2}}{\\sin^{2p-1}\\theta \\cos^{2q-1}\\theta d\\theta}$$ $$let\\ x = \\frac{y}{1+y}, B(p,q) = \\int_0^1\\frac{y^{p-1}}{(y+1)^{p+q}}dy.$$ (1) 对偶性$B(p,q)=B(q,p)$由区间再现，$B(p,q)=\\int_0^1x^{p-1}(1-x)^{q-1}dx = \\int_0^1(1-x)^{p-1}x^{q-1}dx = B(p, q).$ (2) $B(p,q)$在定义域上连续，且有任意阶连续偏导数.(3) 递推公式$$B(p,q+1)=\\frac{q}{p+q}B(p,q),\\ B(p+1,q)=\\frac{p}{p+q}$$ PROOF: $$B(p,q)=\\int_0^1x^{p-1}(1-x)^{q-1}dx=\\frac{1}{p}\\int_0^1(1-x)^{q-1}dx^p$$ $$=\\frac{1}{p}(1-x)^{q-1}x^p|_0^1+\\frac{q-1}{p}\\int_0^1x^p(1-x)^{q-2}dx$$ $$=\\frac{q-1}{p}\\int_0^1x^{p-1}(1-(1-x))(1-x)^{q-2}dx$$ $$=\\frac{q-1}{p}[\\int_0^1{x^{p-1}(1-x)^{(q-2)}dx}-{\\int_0^1x^{p-1}(1-x)^{q-1}dx}]$$ $$=\\frac{q-1}{p}[{B(p,q-1)-B(p,q)}]$$ $$B(p,q+1) = \\frac{q}{p}[(B(p,q)-B(p,q+1))]$$ $$B(p,q+1)=\\frac{q}{p+q}B(p,q)$$ 由对偶性, $B(p+1,q) = \\frac{p}{p+q}B(p,q).$ (4) 设$p&gt;0$ $$B(p,p)=\\frac{1}{2^{2p-1}}B(\\frac{1}{2},p)$$ PROOF: $$B(p,p)=2\\int_0^{\\frac{\\pi}{2}}{(\\sin^{2p-1}\\theta) (\\cos^{2p-1}\\theta) d\\theta}$$ $$=\\frac{2}{2^{2p-1}}\\int_0^{\\frac{\\pi}{2}}(2\\sin\\theta \\cos\\theta)^{2p-1}d\\theta$$ $$=\\frac{1}{2^{2p-1}}\\int_0^{\\frac{\\pi}{2}}(\\sin(2\\theta))^{(2p-1)}d(2\\theta)$$ $$=\\frac{1}{2^{2p-1}}\\int_0^{\\pi}\\sin^{(2p-1)}\\theta d\\theta$$ $$=\\frac{1}{2^{2p-1}}2\\int_0^{\\frac{\\pi}{2}}\\sin^{(2p-1)}\\theta d\\theta$$ $$=\\frac{1}{2^{2p-1}}B(\\frac{1}{2},p).$$","link":"/2023/12/28/%E5%90%84%E7%A7%8D%E7%A7%AF%E5%88%86/"},{"title":"CF1946","text":"A - Median of an Array题意：加多少次1可以改变中位数大小。 显然比中位数位置大的与中位数相同的数有多少个就加多少次 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;int a[100000];int main() { int T; cin &gt;&gt; T; while (T--) { int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; sort(a + 1, a + n + 1); int k = (n + 1) / 2, ans = 0; for (int i = k; i &lt;= n; i++) { if (a[i] == a[k]) ans++; } cout &lt;&lt; ans &lt;&lt; endl; } return 0;} B - Maximum Sum题意：一个长度为$n$的数组$a$，你可以进行k次操作，每一次操作选一个子段和添加到数组的任意位置，最大化数组总和。 当最大子段和小于$0$时显然不进行操作，当最大子段和大于$0$时不断加入$k$次目前最大子段和。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const long long mod = 1000000007ll;long long T, a[200010], SUM;void work() { int n, k; SUM = 0; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i], SUM += a[i], SUM %= mod; long long ans = 0, sum = 0; for (int i = 1; i &lt;= n; ++i) { sum += a[i]; if (sum &gt; ans) { ans = sum; } else if (sum &lt; 0) { sum = 0; } } sum = 0; for (int i = 1; i &lt;= k; ++i) { sum = (sum + ans) % mod; ans = (ans + ans) % mod; } cout &lt;&lt; (SUM + sum + 2ll * mod) % mod &lt;&lt; endl;}int main() { cin &gt;&gt; T; while (T--) work(); return 0;} C - Tree Cutting题意：一棵$n$个点的树，找出最大的$x$，使得在这棵树删掉$k$条边时，每个剩余的联通块大小至少为$x$ 对于每一个$x$，我们可以考虑在剩余联通块大小至少为$x$时，可以删掉几条边。不难发现，$x$变大时，$k$变小，$x$变小时，$k$变大。所以可以考虑二分$x$，进行检验是否能删到至少k条边。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;int n, k;vector&lt;int&gt; e[100010];void add(int x, int y) { e[x].emplace_back(y); e[y].emplace_back(x);}int cnt[100010], siz[100010];// cnt: 可删边的个数// siz: 不包含已经割掉的子树大小的大小void dfs(int fa, int u, int x) { cnt[u] = 0; siz[u] = 1; for (auto v: e[u]) { if (v == fa) continue; dfs(u, v, x); cnt[u] += cnt[v]; if (siz[v] &gt;= x) { cnt[u]++; siz[v] = 0; } siz[u] += siz[v]; }}bool check(int num) { dfs(-1, 1, num); if (siz[1] &gt;= num) cnt[1]++; if (cnt[1] &gt;= k + 1) return true; return false; }void work() { cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) e[i].clear(); for (int i = 1, x, y; i &lt; n; i++) { cin &gt;&gt; x &gt;&gt; y; add(x, y); } int l = 0, r = n, ans = 0; while (l &lt;= r) { int mid = (l + r) &gt;&gt; 1; if (check(mid)) { l = mid + 1; ans = mid; } else r = mid - 1; } cout &lt;&lt; ans &lt;&lt; endl;}int main() { int T; cin &gt;&gt; T; while (T--) work(); return 0;} D - Birthday Gift题意：有一个长度为$n$的数组$a$，还有一个数字$x$，找到最大的$k$，使得可以将$a$划分成$k$组，同时满足: $$(a_{l_1} \\oplus\\ a_{l_1 +1} \\oplus\\ …\\ \\oplus\\ a_{r_1}) |(a_{l_2} \\oplus\\ a_{l_2 +1} \\oplus\\ …\\ \\oplus\\ a_{r_2})|…|(a_{l_k} \\oplus\\ a_{l_k +1} \\oplus\\ …\\ \\oplus\\ a_{r_k}) \\le x$$ 首先对$a$进行异或前缀和，然后从二进制高位到低位逐位进行判断。异或前缀和为$S_i$。 则以上式子转化为： $$(S_{r_1}\\ \\oplus\\ S_{r_2})|(S_{r_2}\\ \\oplus\\ S_{r_3})|…|(S_{r_{n-1}}\\ \\oplus\\ S_{r_{n}}) \\le x$$ 对于每一个二进制位，x只有两种情况。 x = 1时，如果能在$S_{r_i}$取到k个0，那么显然合法，若不行则比较下一位 x = 0时，如果凑不到k个0，那么则说明这一位会取1则不合法。如果能凑到，就与上一位合并，继续比较下一位。 设$S_1$是这一轮之前的使得结果与x相等的$r_i$集合，$S_2$为当前位为0的集合，$S_3$是这一轮与上一轮同时合法的集合，即$S_3 = S_1 \\ \\And \\ S_2$。那么通过统计$S_3$为1的数量，即可统计出这一位能划分出多少组。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;long long n, x;long long a[200010];vector&lt;bool&gt; s1, s2, s3;bool check(int mid) { for (int i = 1; i &lt;= n; i++) s1[i] = true; int cnt; for (long long b = 32; b &gt;= 0; b--) { for (int i = 0; i &lt;= n; i++) s2[i] = false; for (int i = 1; i &lt;= n; i++) { if (!(a[i] &amp; (1ll &lt;&lt; b))) s2[i] = true; } cnt = 0; for (int i = 1; i &lt;= n; i++) { s3[i] = s1[i] &amp; s2[i]; cnt += s3[i]; } if (x &amp; (1ll &lt;&lt; b)) { if (cnt &gt;= mid &amp;&amp; s3[n]) return true; } else { if (cnt &lt; mid || !s3[n]) return false; for (int i = 1; i &lt;= n; i++) s1[i] = s3[i]; } } return true;}void work() { cin &gt;&gt; n &gt;&gt; x; s1.clear(); s2.clear(); s3.clear(); s1.reserve(n + 10); s2.reserve(n + 10); s3.reserve(n + 10); for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; a[i] = a[i] ^ a[i - 1]; } long long l = 0, r = n, ans = 0, mid; while (l &lt;= r) { mid = (l + r) &gt;&gt; 1ll; if (check(mid)) { l = mid + 1; ans = mid; } else r = mid - 1; } if (ans != 0) cout &lt;&lt; ans &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; return ;}int main() { int T; cin &gt;&gt; T; while (T--) work(); return 0;} E - Girl Permutation题意：有一个长度为$n$的排列，给定前缀最大值的索引$P_i$和后缀最大值的索引$S_i$，求满足条件的排列数量。 首先，可以发现$P_1 = 1, P_{m_1}=S_1,S_{m_2}=n$，若不满足则不存在这样的排列。 然后对于整个排列的最大值的位置是已知的，即$P_{m_1}=S_1$这个位置。 先考虑最大值位置左边，右边可以通过类似的计算得出结果。 对于这个位置左边，每一个$P_i$和$P_{i+1}$之间存在的空隙影响这排列个数。我们可以从$P_{m_1}$往左看，每个$P_i$和$P_{i+1}$间有$P_{i+1}-P_i-1$个数，同时在$P_{i+1}$左边可取的数为$P_{i+1}-2$个（除去$P_i$和$P_{i+1}$这两个数），所以此时的方案数是 $$\\tbinom{P_{i+1}-2}{P_{i+1}-P_{i}-1} \\times ({P_{i+1}-P_{i}-1})!$$​ 化简得： $$\\frac{(P_{i+1}-2)!}{(P_{i}-1)!}$$ 同理可计算出右边方案数为： $$\\frac{(n-S_i-1)!}{(n-S_{i+1})!}$$ 最后再乘上$\\binom{n-1}{S_1-1}$即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;const long long mod = 1000000007ll;long long fac[200010], invFac[200010];long long qpow(long long x, long long p) { if (x == 0) return 0; if (x == 1 || p == 0) return 1; long long ans = 1; while (p) { if (p &amp; 1) ans = ans * x % mod; x = x * x % mod; p &gt;&gt;= 1ll; } return ans;}void init() { fac[0] = 1; for (int i = 1; i &lt;= 200000; i++) fac[i] = (fac[i - 1] * i) % mod; invFac[200000] = qpow(fac[200000], mod - 2); for (int i = 199999; i &gt;= 0; i--) invFac[i] = invFac[i + 1] * (i + 1) % mod;}long long C(int n, int m) { return (fac[n] * (invFac[n - m] * invFac[m] % mod) % mod);}void work() { int n, m1, m2; cin &gt;&gt; n &gt;&gt; m1 &gt;&gt; m2; vector&lt;int&gt; p(m1 + 1), s(m2 + 1); for (int i = 1, x; i &lt;= m1; i++) cin &gt;&gt; p[i]; for (int i = 1, x; i &lt;= m2; i++) cin &gt;&gt; s[i]; if (p[m1] != s[1] || p[1] != 1 || s[m2] != n) { cout &lt;&lt; &quot;0\\n&quot;; return ; } long long ans1 = 1, ans2 = 1; for (int i = m1 - 1; i &gt;= 1; i--) { ans1 = (ans1 * fac[p[i + 1] - 2] % mod) * invFac[p[i] - 1] % mod; } for (int i = 1; i &lt; m2; i++) { ans2 = (ans2 * fac[n - s[i] - 1] % mod) * invFac[n - s[i + 1]] % mod; } cout &lt;&lt; (ans1 * ans2 % mod) * C(n - 1, s[1] - 1) % mod &lt;&lt; endl;}int main() { init(); int T; cin &gt;&gt; T; while (T--) work(); return 0;}","link":"/2024/03/23/CF1946/"},{"title":"双Hash","text":"CF1944D - Non-Palindromic Substring题意：称一个字符串为$k$-good字符串，当该字符串至少有一个长度为$k$的子串不是回文串。给定一个字符串，询问$[l, r]$子串的$\\sum{k}$ 通过模拟可以发现对于一个字符串： 不是回文串，则$k$可以取$2 \\sim len$中的每一个值。 每个字符都相同，则答案为$0$。 是交错型的字符串，则$k$可以取$2 \\sim len$中的每一个偶数。 只是回文串，则$k$可以取$2 \\sim {len - 1}$中的每一个值。 判断回文串使用了双Hash（好久没用过了，写一个规范点的出来用） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;#include &lt;chrono&gt;#include &lt;random&gt;using namespace std;const int N = 200010;namespace RAND { unsigned int SEED() { auto now = chrono::system_clock::now(); auto timestamp = chrono::duration_cast&lt;chrono::milliseconds&gt;(now.time_since_epoch()); return static_cast&lt;unsigned int&gt;(timestamp.count()); } mt19937 R(SEED());} // namespace RANDunsigned long long mod1 = RAND::R(), mod2 = RAND::R();class HASH { typedef unsigned long long ull; typedef pair&lt;ull, ull&gt; pULL;public: ull base, pow1[N], pow2[N]; vector&lt;ull&gt; hash1, hash2; HASH() { base = 27; pow1[0] = pow2[0] = 1; for (int i = 1; i &lt; N; ++i) { pow1[i] = (pow1[i - 1] * base) % mod1; pow2[i] = (pow2[i - 1] * base) % mod2; } } // 默认字符串从1开始 void init(string s) { int len = s.size() - 1; hash1.reserve(s.size()), hash2.reserve(s.size()); hash1[0] = hash2[0] = 0; for (int i = 1; i &lt;= len; ++i) { hash1[i] = (hash1[i - 1] * base + s[i] - 'a') % mod1; hash2[i] = (hash2[i - 1] * base + s[i] - 'a') % mod2; } } pULL subHash(int l, int r) { if (l == 1) return make_pair(hash1[r], hash2[r]); pULL tmp; tmp.first = (hash1[r] - hash1[l - 1] * pow1[r - l + 1] % mod1 + mod1) % mod1; tmp.second = (hash2[r] - hash2[l - 1] * pow2[r - l + 1] % mod2 + mod2) % mod2; return tmp; }} hashFront, hashBack;int n, q;string s;void work() { cin &gt;&gt; n &gt;&gt; q; cin &gt;&gt; s; hashFront.init(&quot; &quot; + s); reverse(s.begin(), s.end()); hashBack.init(&quot; &quot; + s); reverse(s.begin(), s.end()); int len = s.size(); s = &quot; &quot; + s; unsigned long long ans, L; vector&lt;int&gt; id(n + 1); id[1] = 1, id[2] = 2; for (int i = 3; i &lt;= len; i++) { if (s[i] == s[i - 2]) id[i] = id[i - 2]; else id[i] = i; } vector&lt;int&gt; con(n + 1); con[1] = 1; for (int i = 2; i &lt;= len; i++) { if (s[i] == s[i - 1]) con[i] = con[i - 1]; else con[i] = i; } for (int i = 1, l, r; i &lt;= q; ++i) { cin &gt;&gt; l &gt;&gt; r; L = (r - l + 1); if (L == 1) { cout &lt;&lt; &quot;0\\n&quot;; continue; } if (L == 2) { if (s[l] == s[r]) cout &lt;&lt; &quot;0\\n&quot;; else cout &lt;&lt; &quot;2\\n&quot;; continue; } auto x1 = hashFront.subHash(l, r); auto x2 = hashBack.subHash(len - r + 1, len - l + 1); if (x1 == x2) { bool flag = 1; if (con[r] == con[l]) { cout &lt;&lt; 0 &lt;&lt; '\\n'; continue; } if (id[l] == id[r] &amp;&amp; id[l + 1] == id[r - 1]) { unsigned long long tmp = (L / 2) * 2; ans = (2 + tmp) * (L / 2) / 2; } else { ans = (1 + L - 1) * (L - 1) / 2 - 1; } } else { if (id[l] == id[r - 1] &amp;&amp; id[l + 1] == id[r]) { ans = (2 + L) * L / 4; } else ans = (2 + L) * (L - 1) / 2; } cout &lt;&lt; ans &lt;&lt; '\\n'; }}int main() { ios::sync_with_stdio(0); cin.tie(0); int T; cin &gt;&gt; T; while (T--) work(); return 0;}","link":"/2024/03/25/%E5%8F%8CHash/"}],"tags":[{"name":"微积分","slug":"微积分","link":"/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"},{"name":"Codeforces","slug":"Codeforces","link":"/tags/Codeforces/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"categories":[{"name":"数学","slug":"数学","link":"/categories/%E6%95%B0%E5%AD%A6/"},{"name":"CF","slug":"CF","link":"/categories/CF/"},{"name":"XCPC","slug":"XCPC","link":"/categories/XCPC/"}],"pages":[]}