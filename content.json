{"posts":[{"title":"各种积分","text":"$Guass$积分$$\\int_{0}^{+\\infty}e^{-x^{2}}dx$$ 设$I(t)={(\\int_{0}^{t} e^{-x^{2}}dx)}^2$, 则求 $$\\sqrt{\\lim\\limits_{t \\to +\\infty}I(t)}$$ $$I^{‘}(t) = 2(\\int_{0}^{t}e^{-x^{2}}dx)e^{-t^2} = 2\\int_{0}^{t}e^{-x^2-t^2}dx = 2\\int_{0}^{1}2te^{(y^2+1)t^2}dy$$ $$\\frac{dI(t)}{dt} = \\frac{\\int_0^1\\frac{e^{-(y^2+1)t^2}}{-(y^2+1)}dy}{dt}$$ $$I(t) = \\int_0^1\\frac{e^{-(y^2+1)t^2}}{-(y^2+1)}+C$$ $$I(0)=\\int_0^1\\frac{-1}{y^2+1}dy+C = -\\frac{\\pi}{4} + C=0,C=\\frac{\\pi}{4}$$ $$I(t) = \\int_0^1\\frac{e^{-(y^2+1)t^2}}{-(y^2+1)}+\\frac{\\pi}{4}$$ $$\\lim\\limits_{t \\to +\\infty}I(t)=0+\\frac{\\pi}{4} = \\frac{\\pi}{4}$$ $$\\therefore\\int_{0}^{+\\infty}e^{-x^{2}}dx=\\frac{\\sqrt{\\pi}}{2}$$ $Euler$积分$Beta$函数$$B(p,q)=\\int_0^1x^{p-1}(1-x)^{q-1}dx\\ (p &gt; 0, q &gt; 0)$$ $$let\\ x = \\sin^2\\theta,B(p,q)=\\int_0^{\\frac{\\pi}{2}}{(\\sin\\theta)^{2p-2} (\\cos\\theta)^{2q-2} d(\\sin^2\\theta)} = \\int_0^{\\frac{\\pi}{2}}{\\sin^{2p-1}\\theta \\cos^{2q-1}\\theta d\\theta}$$ $$let\\ x = \\frac{y}{1+y}, B(p,q) = \\int_0^1\\frac{y^{p-1}}{(y+1)^{p+q}}dy.$$ (1) 对偶性$B(p,q)=B(q,p)$由区间再现，$B(p,q)=\\int_0^1x^{p-1}(1-x)^{q-1}dx = \\int_0^1(1-x)^{p-1}x^{q-1}dx = B(p, q).$ (2) $B(p,q)$在定义域上连续，且有任意阶连续偏导数.(3) 递推公式$$B(p,q+1)=\\frac{q}{p+q}B(p,q),\\ B(p+1,q)=\\frac{p}{p+q}$$ PROOF: $$B(p,q)=\\int_0^1x^{p-1}(1-x)^{q-1}dx=\\frac{1}{p}\\int_0^1(1-x)^{q-1}dx^p$$ $$=\\frac{1}{p}(1-x)^{q-1}x^p|_0^1+\\frac{q-1}{p}\\int_0^1x^p(1-x)^{q-2}dx$$ $$=\\frac{q-1}{p}\\int_0^1x^{p-1}(1-(1-x))(1-x)^{q-2}dx$$ $$=\\frac{q-1}{p}[\\int_0^1{x^{p-1}(1-x)^{(q-2)}dx}-{\\int_0^1x^{p-1}(1-x)^{q-1}dx}]$$ $$=\\frac{q-1}{p}[{B(p,q-1)-B(p,q)}]$$ $$B(p,q+1) = \\frac{q}{p}[(B(p,q)-B(p,q+1))]$$ $$B(p,q+1)=\\frac{q}{p+q}B(p,q)$$ 由对偶性, $B(p+1,q) = \\frac{p}{p+q}B(p,q).$ (4) 设$p&gt;0$ $$B(p,p)=\\frac{1}{2^{2p-1}}B(\\frac{1}{2},p)$$ PROOF: $$B(p,p)=2\\int_0^{\\frac{\\pi}{2}}{(\\sin^{2p-1}\\theta) (\\cos^{2p-1}\\theta) d\\theta}$$ $$=\\frac{2}{2^{2p-1}}\\int_0^{\\frac{\\pi}{2}}(2\\sin\\theta \\cos\\theta)^{2p-1}d\\theta$$ $$=\\frac{1}{2^{2p-1}}\\int_0^{\\frac{\\pi}{2}}(\\sin(2\\theta))^{(2p-1)}d(2\\theta)$$ $$=\\frac{1}{2^{2p-1}}\\int_0^{\\pi}\\sin^{(2p-1)}\\theta d\\theta$$ $$=\\frac{1}{2^{2p-1}}2\\int_0^{\\frac{\\pi}{2}}\\sin^{(2p-1)}\\theta d\\theta$$ $$=\\frac{1}{2^{2p-1}}B(\\frac{1}{2},p).$$","link":"/2023/12/28/%E5%90%84%E7%A7%8D%E7%A7%AF%E5%88%86/"},{"title":"CF1946","text":"A - Median of an Array题意：加多少次1可以改变中位数大小。 显然比中位数位置大的与中位数相同的数有多少个就加多少次 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;int a[100000];int main() { int T; cin &gt;&gt; T; while (T--) { int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; sort(a + 1, a + n + 1); int k = (n + 1) / 2, ans = 0; for (int i = k; i &lt;= n; i++) { if (a[i] == a[k]) ans++; } cout &lt;&lt; ans &lt;&lt; endl; } return 0;} B - Maximum Sum题意：一个长度为n的数组a，你可以进行k次操作，每一次操作选一个子段和添加到数组的任意位置，最大化数组总和。 当最大子段和小于0时显然不进行操作，当最大子段和大于0时不断加入k次目前最大子段和。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const long long mod = 1000000007ll;long long T, a[200010], SUM;void work() { int n, k; SUM = 0; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i], SUM += a[i], SUM %= mod; long long ans = 0, sum = 0; for (int i = 1; i &lt;= n; ++i) { sum += a[i]; if (sum &gt; ans) { ans = sum; } else if (sum &lt; 0) { sum = 0; } } // 最大子段和 sum = 0; for (int i = 1; i &lt;= k; ++i) { sum = (sum + ans) % mod; ans = (ans + ans) % mod; } cout &lt;&lt; (SUM + sum + 2ll * mod) % mod &lt;&lt; endl;}int main() { cin &gt;&gt; T; while (T--) work(); return 0;} C - Tree Cutting题意：一棵n个点的树，找出最大的x，使得在这棵树删掉k条边时，每个剩余的联通块大小至少为x 对于每一个x，我们可以考虑在剩余联通块大小至少为x时，可以删掉几条边。不难发现，x变大时，k变小，x变小时，k变大。所以可以考虑二分x，进行检验是否能删到至少k条边。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;int n, k;vector&lt;int&gt; e[100010];void add(int x, int y) { e[x].emplace_back(y); e[y].emplace_back(x);}int cnt[100010], siz[100010];// cnt: 可删边的个数// siz: 不包含已经割掉的子树大小的大小void dfs(int fa, int u, int x) { cnt[u] = 0; siz[u] = 1; for (auto v: e[u]) { if (v == fa) continue; dfs(u, v, x); cnt[u] += cnt[v]; if (siz[v] &gt;= x) { cnt[u]++; siz[v] = 0; } siz[u] += siz[v]; }}bool check(int num) { dfs(-1, 1, num); if (siz[1] &gt;= num) cnt[1]++; if (cnt[1] &gt;= k + 1) return true; return false; }void work() { cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) e[i].clear(); for (int i = 1, x, y; i &lt; n; i++) { cin &gt;&gt; x &gt;&gt; y; add(x, y); } int l = 0, r = n, ans = 0; while (l &lt;= r) { int mid = (l + r) &gt;&gt; 1; if (check(mid)) { l = mid + 1; ans = mid; } else r = mid - 1; } cout &lt;&lt; ans &lt;&lt; endl;}int main() { int T; cin &gt;&gt; T; while (T--) work(); return 0;}","link":"/2024/03/23/CF1946/"}],"tags":[{"name":"微积分","slug":"微积分","link":"/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"},{"name":"Codeforces","slug":"Codeforces","link":"/tags/Codeforces/"}],"categories":[{"name":"数学","slug":"数学","link":"/categories/%E6%95%B0%E5%AD%A6/"},{"name":"CF","slug":"CF","link":"/categories/CF/"}],"pages":[]}