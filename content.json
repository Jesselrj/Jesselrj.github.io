{"posts":[{"title":"各种积分","text":"$Guass$积分$$\\int_{0}^{+\\infty}e^{-x^{2}}dx$$ 设$I(t)={(\\int_{0}^{t} e^{-x^{2}}dx)}^2$, 则求 $$\\sqrt{\\lim\\limits_{t \\to +\\infty}I(t)}$$ $$I^{‘}(t) = 2(\\int_{0}^{t}e^{-x^{2}}dx)e^{-t^2} = 2\\int_{0}^{t}e^{-x^2-t^2}dx = 2\\int_{0}^{1}2te^{(y^2+1)t^2}dy$$ $$\\frac{dI(t)}{dt} = \\frac{\\int_0^1\\frac{e^{-(y^2+1)t^2}}{-(y^2+1)}dy}{dt}$$ $$I(t) = \\int_0^1\\frac{e^{-(y^2+1)t^2}}{-(y^2+1)}+C$$ $$I(0)=\\int_0^1\\frac{-1}{y^2+1}dy+C = -\\frac{\\pi}{4} + C=0,C=\\frac{\\pi}{4}$$ $$I(t) = \\int_0^1\\frac{e^{-(y^2+1)t^2}}{-(y^2+1)}+\\frac{\\pi}{4}$$ $$\\lim\\limits_{t \\to +\\infty}I(t)=0+\\frac{\\pi}{4} = \\frac{\\pi}{4}$$ $$\\therefore\\int_{0}^{+\\infty}e^{-x^{2}}dx=\\frac{\\sqrt{\\pi}}{2}$$ $Euler$积分$Beta$函数$$B(p,q)=\\int_0^1x^{p-1}(1-x)^{q-1}dx\\ (p &gt; 0, q &gt; 0)$$ $$let\\ x = \\sin^2\\theta,B(p,q)=\\int_0^{\\frac{\\pi}{2}}{(\\sin\\theta)^{2p-2} (\\cos\\theta)^{2q-2} d(\\sin^2\\theta)} = \\int_0^{\\frac{\\pi}{2}}{\\sin^{2p-1}\\theta \\cos^{2q-1}\\theta d\\theta}$$ $$let\\ x = \\frac{y}{1+y}, B(p,q) = \\int_0^1\\frac{y^{p-1}}{(y+1)^{p+q}}dy.$$ (1) 对偶性$B(p,q)=B(q,p)$由区间再现，$B(p,q)=\\int_0^1x^{p-1}(1-x)^{q-1}dx = \\int_0^1(1-x)^{p-1}x^{q-1}dx = B(p, q).$ (2) $B(p,q)$在定义域上连续，且有任意阶连续偏导数.(3) 递推公式$$B(p,q+1)=\\frac{q}{p+q}B(p,q),\\ B(p+1,q)=\\frac{p}{p+q}$$ PROOF: $$B(p,q)=\\int_0^1x^{p-1}(1-x)^{q-1}dx=\\frac{1}{p}\\int_0^1(1-x)^{q-1}dx^p$$ $$=\\frac{1}{p}(1-x)^{q-1}x^p|_0^1+\\frac{q-1}{p}\\int_0^1x^p(1-x)^{q-2}dx$$ $$=\\frac{q-1}{p}\\int_0^1x^{p-1}(1-(1-x))(1-x)^{q-2}dx$$ $$=\\frac{q-1}{p}[\\int_0^1{x^{p-1}(1-x)^{(q-2)}dx}-{\\int_0^1x^{p-1}(1-x)^{q-1}dx}]$$ $$=\\frac{q-1}{p}[{B(p,q-1)-B(p,q)}]$$ $$B(p,q+1) = \\frac{q}{p}[(B(p,q)-B(p,q+1))]$$ $$B(p,q+1)=\\frac{q}{p+q}B(p,q)$$ 由对偶性, $B(p+1,q) = \\frac{p}{p+q}B(p,q).$ (4) 设$p&gt;0$ $$B(p,p)=\\frac{1}{2^{2p-1}}B(\\frac{1}{2},p)$$ PROOF: $$B(p,p)=2\\int_0^{\\frac{\\pi}{2}}{(\\sin^{2p-1}\\theta) (\\cos^{2p-1}\\theta) d\\theta}$$ $$=\\frac{2}{2^{2p-1}}\\int_0^{\\frac{\\pi}{2}}(2\\sin\\theta \\cos\\theta)^{2p-1}d\\theta$$ $$=\\frac{1}{2^{2p-1}}\\int_0^{\\frac{\\pi}{2}}(\\sin(2\\theta))^{(2p-1)}d(2\\theta)$$ $$=\\frac{1}{2^{2p-1}}\\int_0^{\\pi}\\sin^{(2p-1)}\\theta d\\theta$$ $$=\\frac{1}{2^{2p-1}}2\\int_0^{\\frac{\\pi}{2}}\\sin^{(2p-1)}\\theta d\\theta$$ $$=\\frac{1}{2^{2p-1}}B(\\frac{1}{2},p).$$","link":"/2023/12/28/%E5%90%84%E7%A7%8D%E7%A7%AF%E5%88%86/"},{"title":"CF1946","text":"A - Median of an Array题意：加多少次1可以改变中位数大小。 显然比中位数位置大的与中位数相同的数有多少个就加多少次 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;int a[100000];int main() { int T; cin &gt;&gt; T; while (T--) { int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; sort(a + 1, a + n + 1); int k = (n + 1) / 2, ans = 0; for (int i = k; i &lt;= n; i++) { if (a[i] == a[k]) ans++; } cout &lt;&lt; ans &lt;&lt; endl; } return 0;} B - Maximum Sum题意：一个长度为$n$的数组$a$，你可以进行k次操作，每一次操作选一个子段和添加到数组的任意位置，最大化数组总和。 当最大子段和小于$0$时显然不进行操作，当最大子段和大于$0$时不断加入$k$次目前最大子段和。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const long long mod = 1000000007ll;long long T, a[200010], SUM;void work() { int n, k; SUM = 0; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i], SUM += a[i], SUM %= mod; long long ans = 0, sum = 0; for (int i = 1; i &lt;= n; ++i) { sum += a[i]; if (sum &gt; ans) { ans = sum; } else if (sum &lt; 0) { sum = 0; } } // 最大子段和 sum = 0; for (int i = 1; i &lt;= k; ++i) { sum = (sum + ans) % mod; ans = (ans + ans) % mod; } cout &lt;&lt; (SUM + sum + 2ll * mod) % mod &lt;&lt; endl;}int main() { cin &gt;&gt; T; while (T--) work(); return 0;} C - Tree Cutting题意：一棵$n$个点的树，找出最大的$x$，使得在这棵树删掉$k$条边时，每个剩余的联通块大小至少为$x$ 对于每一个$x$，我们可以考虑在剩余联通块大小至少为$x$时，可以删掉几条边。不难发现，$x$变大时，$k$变小，$x$变小时，$k$变大。所以可以考虑二分$x$，进行检验是否能删到至少k条边。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;int n, k;vector&lt;int&gt; e[100010];void add(int x, int y) { e[x].emplace_back(y); e[y].emplace_back(x);}int cnt[100010], siz[100010];// cnt: 可删边的个数// siz: 不包含已经割掉的子树大小的大小void dfs(int fa, int u, int x) { cnt[u] = 0; siz[u] = 1; for (auto v: e[u]) { if (v == fa) continue; dfs(u, v, x); cnt[u] += cnt[v]; if (siz[v] &gt;= x) { cnt[u]++; siz[v] = 0; } siz[u] += siz[v]; }}bool check(int num) { dfs(-1, 1, num); if (siz[1] &gt;= num) cnt[1]++; if (cnt[1] &gt;= k + 1) return true; return false; }void work() { cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) e[i].clear(); for (int i = 1, x, y; i &lt; n; i++) { cin &gt;&gt; x &gt;&gt; y; add(x, y); } int l = 0, r = n, ans = 0; while (l &lt;= r) { int mid = (l + r) &gt;&gt; 1; if (check(mid)) { l = mid + 1; ans = mid; } else r = mid - 1; } cout &lt;&lt; ans &lt;&lt; endl;}int main() { int T; cin &gt;&gt; T; while (T--) work(); return 0;} D - Birthday Gift题意：有一个长度为$n$的数组$a$，还有一个数字$x$，找到最大的$k$，使得可以将$a$划分成$k$组，同时满足: $$(a_{l_1} \\oplus\\ a_{l_1 +1} \\oplus\\ …\\ \\oplus\\ a_{r_1} |(a_{l_2} \\oplus\\ a_{l_2 +1} \\oplus\\ …\\ \\oplus\\ a_{r_2})|…|(a_{l_k} \\oplus\\ a_{l_k +1} \\oplus\\ …\\ \\oplus\\ a_{r_k}) \\le x$$ 首先对$a$进行异或前缀和，然后从二进制高位到低位逐位进行判断。异或前缀和为$S_i$。 则以上式子转化为： $$(S_{r_1}\\ \\oplus\\ S_{r_2})|(S_{r_2}\\ \\oplus\\ S_{r_3})|…|(S_{r_{n-1}}\\ \\oplus\\ S_{r_{n}}) \\le x$$ 对于每一个二进制位，x只有两种情况。 x = 1时，如果能在$S_{r_i}$取到k个0，那么显然合法，若不行则比较下一位 x = 0时，如果凑不到k个0，那么则说明这一位会取1则不合法。如果能凑到，就与上一位合并，继续比较下一位。 设$S_1$是这一轮之前的使得结果与x相等的$r_i$集合，$S_2$为当前位为0的集合，$S_3$是这一轮与上一轮同时合法的集合，即$S_3 = S_1 \\ \\And \\ S_2$。那么通过统计$S_3$为1的数量，即可统计出这一位能划分出多少组。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;long long n, x;long long a[200010];vector&lt;bool&gt; s1, s2, s3;bool check(int mid) { for (int i = 1; i &lt;= n; i++) s1[i] = true; int cnt; for (long long b = 32; b &gt;= 0; b--) { for (int i = 0; i &lt;= n; i++) s2[i] = false; for (int i = 1; i &lt;= n; i++) { if (!(a[i] &amp; (1ll &lt;&lt; b))) s2[i] = true; } cnt = 0; for (int i = 1; i &lt;= n; i++) { s3[i] = s1[i] &amp; s2[i]; cnt += s3[i]; } if (x &amp; (1ll &lt;&lt; b)) { if (cnt &gt;= mid &amp;&amp; s3[n]) return true; } else { if (cnt &lt; mid || !s3[n]) return false; for (int i = 1; i &lt;= n; i++) s1[i] = s3[i]; } } return true;}void work() { cin &gt;&gt; n &gt;&gt; x; s1.clear(); s2.clear(); s3.clear(); s1.reserve(n + 10); s2.reserve(n + 10); s3.reserve(n + 10); for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; a[i] = a[i] ^ a[i - 1]; } long long l = 0, r = n, ans = 0, mid; while (l &lt;= r) { mid = (l + r) &gt;&gt; 1ll; if (check(mid)) { l = mid + 1; ans = mid; } else r = mid - 1; } if (ans != 0) cout &lt;&lt; ans &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; return ;}int main() { int T; cin &gt;&gt; T; while (T--) work(); return 0;}","link":"/2024/03/23/CF1946/"}],"tags":[{"name":"微积分","slug":"微积分","link":"/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"},{"name":"Codeforces","slug":"Codeforces","link":"/tags/Codeforces/"}],"categories":[{"name":"数学","slug":"数学","link":"/categories/%E6%95%B0%E5%AD%A6/"},{"name":"CF","slug":"CF","link":"/categories/CF/"}],"pages":[]}